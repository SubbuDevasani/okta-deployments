# Code Generated by Sidekick is for learning and experimentation purposes only.
# tag: final_okta_backup_with_exclusions_and_type_safe_oauth_app_to_authz_mapping (fixed + active-only auth servers)

import os
import sys
import json
import time
import shutil
import stat
import re
from typing import Any, Dict, List, Optional, Tuple, Set, TypedDict, cast

import requests

# ===== Fixed destination root =====
ROOT_REPO_PATH = os.path.abspath("./OKTA")

# ===== Okta env =====
OKTA_DOMAIN_ENV = "OKTA_DOMAIN"       # e.g., your-dev-org.okta.com
OKTA_TOKEN_ENV  = "OKTA_API_TOKEN"

# ===== HTTP/config =====
REQUEST_TIMEOUT: int = 60
PAGE_LIMIT: int = 200
RETRY_COUNT: int = 3
RETRY_BACKOFF_SEC: int = 2

# ===== Exclusions =====
EXCLUDE_APP_NAMES: Set[str] = {
    "okta_enduser",
    "saasure",
    "okta_browser_plugin",
    "okta_flow_sso",
    "flow",
    "okta_iga_reviewer",
    "okta_access_requests_resource_catalog",
    "okta_atspoke_sso",
    "demo platform management",
}
APP_BLOCKLIST_LOWER: Set[str] = {
    "demo_platform_management",
}

# ===== Strongly-typed records =====
class AppIndexEntry(TypedDict, total=False):
    id: str
    label: str
    name: str
    signOnMode: str
    category: Optional[str]
    file: str
    clientIds: List[str]

class AuthzAssociatedApp(TypedDict, total=False):
    id: Optional[str]
    label: Optional[str]
    name: Optional[str]
    signOnMode: Optional[str]
    category: Optional[str]
    file: Optional[str]
    clientId: str

class AuthzEntry(TypedDict, total=False):
    id: str
    name: str
    issuer: Optional[str]
    default: Optional[bool]
    status: Optional[str]
    file: str
    policies_enriched: List[Dict[str, Any]]  # transient
    associatedApps: List[AuthzAssociatedApp]
    allowedClientsSummary: Dict[str, List[str]]

class AuthzInfo(TypedDict, total=False):
    id: str
    name: str
    issuer: Optional[str]
    file: str

# ===== Paths =====
def build_paths(root_repo: str) -> Dict[str, str]:
    return {
        "apps_saml": os.path.join(root_repo, "applications", "saml"),
        "apps_web": os.path.join(root_repo, "applications", "web_type_apps"),
        "apps_service": os.path.join(root_repo, "applications", "service_type_apps"),
        "authz": os.path.join(root_repo, "auth-server-configs"),
        "index": os.path.join(root_repo, "index.json"),
    }

# ===== Utilities =====
def getenv_or_exit(name: str) -> str:
    v = os.environ.get(name)
    if not v:
        print(f"ERROR: Missing environment variable {name}", file=sys.stderr)
        sys.exit(2)
    return v

def ensure_dir(path: str) -> None:
    os.makedirs(path, exist_ok=True)

def _handle_remove_readonly(func, path, exc_info):
    try:
        os.chmod(path, stat.S_IWRITE)
    except Exception:
        pass
    try:
        func(path)
    except Exception:
        pass

def reset_root_repo(root_repo: str) -> None:
    if os.path.isdir(root_repo):
        try:
            shutil.rmtree(root_repo, onerror=_handle_remove_readonly)
        except Exception as e:
            print(f"Warning: Could not remove '{root_repo}' ({e}). Attempting to clean contents.", file=sys.stderr)
            for walk_root, dirs, files in os.walk(root_repo, topdown=False):
                for name in files:
                    fp = os.path.join(walk_root, name)
                    try:
                        os.chmod(fp, stat.S_IWRITE)
                        os.remove(fp)
                    except Exception:
                        pass
                for name in dirs:
                    dp = os.path.join(walk_root, name)
                    try:
                        os.chmod(dp, stat.S_IWRITE)
                        shutil.rmtree(dp, onerror=_handle_remove_readonly)
                    except Exception:
                        pass
    ensure_dir(root_repo)

def http_get(url: str, headers: Dict[str, str]) -> requests.Response:
    last_err: Optional[Exception] = None
    for attempt in range(1, RETRY_COUNT + 1):
        try:
            resp = requests.get(url, headers=headers, timeout=REQUEST_TIMEOUT)
            if resp.status_code in (429, 500, 502, 503, 504):
                retry_after = 0
                try:
                    retry_after = int(resp.headers.get("Retry-After", "0"))
                except Exception:
                    retry_after = 0
                time.sleep(max(RETRY_BACKOFF_SEC * attempt, retry_after))
                continue
            return resp
        except requests.RequestException as e:
            last_err = e
            time.sleep(RETRY_BACKOFF_SEC * attempt)
    if last_err:
        raise last_err
    raise RuntimeError("GET failed without exception")

def paginate(url: str, headers: Dict[str, str]) -> List[Dict[str, Any]]:
    items: List[Dict[str, Any]] = []
    cur: Optional[str] = url
    while cur:
        r = http_get(cur, headers)
        if r.status_code != 200:
            raise RuntimeError(f"GET {cur} failed: {r.status_code} {r.text[:500]}")
        data = r.json()
        if isinstance(data, list):
            items.extend(cast(List[Dict[str, Any]], data))
        else:
            items.append(cast(Dict[str, Any], data))
        next_url: Optional[str] = None
        link = r.headers.get("Link")
        if isinstance(link, str):
            for part in (p.strip() for p in link.split(",")):
                if 'rel="next"' in part:
                    start = part.find("<") + 1
                    end = part.find(">")
                    if 0 < start < end:
                        next_url = part[start:end]
                        break
        cur = next_url
    return items

def safe_filename(name: str) -> str:
    s = str(name or "").strip()
    s = re.sub(r"[^\w\-. ]+", "_", s)
    s = re.sub(r"\s+", "_", s)
    if not s:
        s = "unnamed"
    return s

def write_json(path: str, data: Any) -> None:
    ensure_dir(os.path.dirname(path))
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, sort_keys=True, ensure_ascii=False)

# ===== Exclusion helpers =====
def is_excluded_app(app: Dict[str, Any]) -> bool:
    api_name = str(app.get("name") or "").strip().lower()
    if api_name in EXCLUDE_APP_NAMES:
        return True
    label = str(app.get("label") or "").strip().lower()
    if label in EXCLUDE_APP_NAMES:
        return True
    if api_name in APP_BLOCKLIST_LOWER or label in APP_BLOCKLIST_LOWER:
        return True
    return False

# ===== Okta: Apps =====
def list_active_apps(base_url: str, headers: Dict[str, str]) -> List[Dict[str, Any]]:
    url = f"{base_url}/api/v1/apps?limit={PAGE_LIMIT}&filter=status%20eq%20%22ACTIVE%22"
    return paginate(url, headers)

def get_app(base_url: str, headers: Dict[str, str], app_id: str) -> Dict[str, Any]:
    r = http_get(f"{base_url}/api/v1/apps/{app_id}", headers)
    if r.status_code != 200:
        raise RuntimeError(f"GET app {app_id} failed: {r.status_code} {r.text[:400]}")
    return cast(Dict[str, Any], r.json())

def scrub_app_secrets(app_json: Dict[str, Any]) -> Dict[str, Any]:
    j = json.loads(json.dumps(app_json))
    cred = j.get("credentials")
    if isinstance(cred, dict):
        if "client_secret" in cred:
            cred["client_secret"] = "REDACTED"
        if "oauthClient" in cred and isinstance(cred["oauthClient"], dict) and "client_secret" in cred["oauthClient"]:
            cred["oauthClient"]["client_secret"] = "REDACTED"
        j["credentials"] = cred
    settings = j.get("settings")
    if isinstance(settings, dict):
        oc = settings.get("oauthClient")
        if isinstance(oc, dict) and "client_secret" in oc:
            oc["client_secret"] = "REDACTED"
            settings["oauthClient"] = oc
        j["settings"] = settings
    return j

def classify_app_type(app: Dict[str, Any]) -> Optional[str]:
    sign_on = str(app.get("signOnMode", "")).upper()
    if sign_on == "SAML_2_0":
        return "saml"
    if sign_on == "OPENID_CONNECT":
        settings = cast(Dict[str, Any], app.get("settings") or {})
        oc = cast(Dict[str, Any], settings.get("oauthClient") or {})
        app_type = str(oc.get("application_type", "")).lower()
        if app_type in {"web", "browser"}:
            return "web"
        if app_type == "service":
            return "service"
        return "web"
    return None

def backup_apps_to_repo(base_url: str, headers: Dict[str, str], paths: Dict[str, str]) -> List[AppIndexEntry]:
    apps = list_active_apps(base_url, headers)
    index_entries: List[AppIndexEntry] = []

    for summary in apps:
        app_id = cast(str, summary.get("id") or "")
        if not app_id:
            continue
        try:
            app = get_app(base_url, headers, app_id)
        except Exception as e:
            print(f"[Apps] ERROR fetching {app_id}: {e}", file=sys.stderr)
            continue

        if is_excluded_app(app):
            lbl = app.get("label") or app.get("name") or app_id
            print(f"[Apps] Excluded app: {lbl}")
            continue

        category = classify_app_type(app)
        label = cast(str, app.get("label") or app.get("name") or f"app_{app_id}")
        filename = f"{safe_filename(label)}.json"
        if category == "saml":
            dest = os.path.join(paths["apps_saml"], filename)
        elif category == "service":
            dest = os.path.join(paths["apps_service"], filename)
        else:
            dest = os.path.join(paths["apps_web"], filename)

        if category in {"saml", "web", "service"}:
            app_scrubbed = scrub_app_secrets(app)
            write_json(dest, app_scrubbed)

        # capture clientIds correctly
        client_ids: List[str] = []
        try:
            cred = cast(Dict[str, Any], app.get("credentials") or {})
            cred_oc = cast(Dict[str, Any], cred.get("oauthClient") or {})
            cid_primary = cred_oc.get("client_id")
            if isinstance(cid_primary, str) and cid_primary:
                client_ids.append(cid_primary)
            settings = cast(Dict[str, Any], app.get("settings") or {})
            oc = cast(Dict[str, Any], settings.get("oauthClient") or {})
            cid_fallback = oc.get("client_id")
            if isinstance(cid_fallback, str) and cid_fallback and cid_fallback not in client_ids:
                client_ids.append(cid_fallback)
        except Exception:
            pass

        entry: AppIndexEntry = {
            "id": app_id,
            "label": label,
            "name": cast(str, app.get("name") or ""),
            "signOnMode": cast(str, app.get("signOnMode") or ""),
            "category": category,
            "file": os.path.relpath(dest, os.path.dirname(paths["index"])),
            "clientIds": client_ids,
        }
        index_entries.append(entry)

        if category in {"saml", "web", "service"}:
            print(f"[Apps] Wrote {category}: {label} -> {dest}")
    return index_entries

# ===== Okta: Authorization Servers =====
def list_authz_servers(base_url: str, headers: Dict[str, str]) -> List[Dict[str, Any]]:
    # Get all, we'll filter active later after fetching each server's full record
    return paginate(f"{base_url}/api/v1/authorizationServers?limit={PAGE_LIMIT}", headers)

def get_authz_server(base_url: str, headers: Dict[str, str], sid: str) -> Dict[str, Any]:
    r = http_get(f"{base_url}/api/v1/authorizationServers/{sid}", headers)
    if r.status_code != 200:
        raise RuntimeError(f"GET authz server {sid} failed: {r.status_code} {r.text[:400]}")
    return cast(Dict[str, Any], r.json())

def list_authz_policies(base_url: str, headers: Dict[str, str], sid: str) -> List[Dict[str, Any]]:
    return paginate(f"{base_url}/api/v1/authorizationServers/{sid}/policies?limit={PAGE_LIMIT}", headers)

def list_authz_policy_rules(base_url: str, headers: Dict[str, str], sid: str, policy_id: str) -> List[Dict[str, Any]]:
    return paginate(f"{base_url}/api/v1/authorizationServers/{sid}/policies/{policy_id}/rules?limit={PAGE_LIMIT}", headers)

def list_authz_scopes(base_url: str, headers: Dict[str, str], sid: str) -> List[Dict[str, Any]]:
    return paginate(f"{base_url}/api/v1/authorizationServers/{sid}/scopes?limit={PAGE_LIMIT}", headers)

def extract_allowed_clients_from_policy(policy: Dict[str, Any]) -> Dict[str, Any]:
    out: Dict[str, Any] = {"include": [], "exclude": [], "assigned": [], "filter": None}
    conds = cast(Dict[str, Any], policy.get("conditions") or {})
    clients = cast(Dict[str, Any], conds.get("clients") or {})
    if isinstance(clients, dict):
        inc = clients.get("include") or []
        exc = clients.get("exclude") or []
        assigned = clients.get("assigned") or []
        flt = clients.get("filter")
        if isinstance(inc, list):
            out["include"] = [str(x) for x in inc if isinstance(x, str)]
        if isinstance(exc, list):
            out["exclude"] = [str(x) for x in exc if isinstance(x, str)]
        if isinstance(assigned, list):
            out["assigned"] = [str(x) for x in assigned if isinstance(x, str)]
        if isinstance(flt, str):
            out["filter"] = flt
    return out

def is_active(obj: Dict[str, Any]) -> bool:
    return str(obj.get("status") or "").upper() == "ACTIVE"

def backup_authz_to_repo(base_url: str, headers: Dict[str, str], paths: Dict[str, str]) -> List[AuthzEntry]:
    servers = list_authz_servers(base_url, headers)
    entries: List[AuthzEntry] = []
    for i, s in enumerate(servers, start=1):
        sid = cast(str, s.get("id") or "")
        if not sid:
            continue
        server = get_authz_server(base_url, headers, sid)

        # Exclude default and non-active authorization servers
        if bool(server.get("default")):
            name = server.get("name") or sid
            print(f"[AuthZ] Excluded default auth server: {name}")
            continue
        if not is_active(server):
            name = server.get("name") or sid
            print(f"[AuthZ] Skipping non-active auth server: {name} (status={server.get('status')})")
            continue

        scopes_all = list_authz_scopes(base_url, headers, sid)
        scopes = [sc for sc in scopes_all if is_active(sc)] if scopes_all else []

        policies_all = list_authz_policies(base_url, headers, sid)
        policies_active = [p for p in policies_all if is_active(p)] if policies_all else []

        policies_enriched: List[Dict[str, Any]] = []
        for p in policies_active:
            pid = cast(str, p.get("id") or "")
            if not pid:
                continue
            rules_all = list_authz_policy_rules(base_url, headers, sid, pid)
            rules = [r for r in rules_all if is_active(r)] if rules_all else []
            policies_enriched.append({
                "policy": p,
                "allowed_clients": extract_allowed_clients_from_policy(p),
                "rules": rules,
            })

        consolidated = {
            "server": server,
            "scopes": scopes,
            "policies": policies_enriched
        }

        server_name = cast(str, server.get("name") or server.get("id") or f"server_{i}")
        fn = f"{safe_filename(server_name)}_AUTH_SERVER.json"
        dest = os.path.join(paths["authz"], fn)
        write_json(dest, consolidated)

        entry: AuthzEntry = {
            "id": sid,
            "name": server_name,
            "issuer": cast(Optional[str], server.get("issuer")),
            "default": cast(Optional[bool], server.get("default")),
            "status": cast(Optional[str], server.get("status")),
            "file": os.path.relpath(dest, os.path.dirname(paths["index"])),
            "policies_enriched": policies_enriched,
        }
        entries.append(entry)
        print(f"[AuthZ] Wrote {server_name} -> {dest}")

    return entries

# ===== Mapping helpers =====
def build_clientid_to_app_index(app_index: List[AppIndexEntry]) -> Dict[str, AppIndexEntry]:
    m: Dict[str, AppIndexEntry] = {}
    for a in app_index:
        if str(a.get("signOnMode") or "").upper() != "OPENID_CONNECT":
            continue
        for cid in a.get("clientIds", []):
            if isinstance(cid, str) and cid:
                m[cid] = a
    return m

def build_appid_to_app_index(app_index: List[AppIndexEntry]) -> Dict[str, AppIndexEntry]:
    return {cast(str, a.get("id")): a for a in app_index if isinstance(a.get("id"), str) and a.get("id")}

def build_authz_app_associations(authz_entries: List[AuthzEntry],
                                 clientid_to_app: Dict[str, AppIndexEntry],
                                 appid_to_app: Dict[str, AppIndexEntry]) -> None:
    for e in authz_entries:
        pe_list = e.get("policies_enriched", [])
        associated: List[AuthzAssociatedApp] = []
        include_ids: Set[str] = set()
        exclude_ids: Set[str] = set()
        assigned_ids: Set[str] = set()
        filters: Set[str] = set()

        for pe in pe_list:
            ac = cast(Dict[str, Any], pe.get("allowed_clients") or {})
            for cid in cast(List[str], ac.get("include") or []):
                if isinstance(cid, str) and cid:
                    include_ids.add(cid)
            for cid in cast(List[str], ac.get("exclude") or []):
                if isinstance(cid, str) and cid:
                    exclude_ids.add(cid)
            for cid in cast(List[str], ac.get("assigned") or []):
                if isinstance(cid, str) and cid:
                    assigned_ids.add(cid)
            flt = ac.get("filter")
            if isinstance(flt, str) and flt:
                filters.add(flt)

        for cid in sorted(include_ids | assigned_ids):
            app: Optional[AppIndexEntry] = clientid_to_app.get(cid)
            # If policy values are actually Okta App IDs (0oa...), try mapping by app ID
            if app is None and isinstance(cid, str) and cid.startswith("0oa"):
                app = appid_to_app.get(cid)

            if app:
                associated.append(AuthzAssociatedApp(
                    id=app.get("id"),
                    label=app.get("label"),
                    name=app.get("name"),
                    signOnMode=app.get("signOnMode"),
                    category=cast(Optional[str], app.get("category")),
                    file=app.get("file"),
                    clientId=cid,
                ))
            else:
                associated.append(AuthzAssociatedApp(
                    id=None,
                    label=None,
                    name=None,
                    signOnMode="OPENID_CONNECT",
                    category=None,
                    file=None,
                    clientId=cid,
                ))

        e["associatedApps"] = associated
        e["allowedClientsSummary"] = {
            "include": sorted(include_ids),
            "exclude": sorted(exclude_ids),
            "assigned": sorted(assigned_ids),
            "filters": sorted(filters),
        }
        if "policies_enriched" in e:
            del e["policies_enriched"]

def try_read_client_id_from_saved_app(rel_file_from_index: str) -> Optional[str]:
    """
    Attempts to read client_id from the saved app JSON using both
    credentials.oauthClient.client_id and settings.oauthClient.client_id paths.
    """
    try:
        abs_path = os.path.join(ROOT_REPO_PATH, rel_file_from_index).replace("\\", os.sep)
        if not os.path.isfile(abs_path):
            return None
    except Exception:
        return None
    try:
        with open(abs_path, "r", encoding="utf-8") as f:
            j = json.load(f)
        cred = cast(Dict[str, Any], j.get("credentials") or {})
        cred_oc = cast(Dict[str, Any], cred.get("oauthClient") or {})
        cid = cred_oc.get("client_id")
        if isinstance(cid, str) and cid:
            return cid
        settings = cast(Dict[str, Any], j.get("settings") or {})
        oc = cast(Dict[str, Any], settings.get("oauthClient") or {})
        cid = oc.get("client_id")
        if isinstance(cid, str) and cid:
            return cid
    except Exception:
        return None
    return None

def reverse_map_apps_to_authz(
    apps_index: List[AppIndexEntry],
    authz_entries: List[AuthzEntry]
) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]]]:
    # clientId -> list of auth server infos
    client_to_authz: Dict[str, List[AuthzInfo]] = {}

    for authz in authz_entries:
        authz_info: AuthzInfo = {
            "id": cast(str, authz.get("id") or ""),
            "name": cast(str, authz.get("name") or ""),
            "issuer": cast(Optional[str], authz.get("issuer")),
            "file": cast(str, authz.get("file") or ""),
        }
        if not authz_info["id"] or not authz_info["name"]:
            continue

        for assoc in authz.get("associatedApps", []) or []:
            cid = assoc.get("clientId")
            if not isinstance(cid, str) or not cid:
                continue
            lst = client_to_authz.get(cid)
            if lst is None:
                client_to_authz[cid] = [authz_info]
            else:
                if all(x.get("id") != authz_info["id"] for x in lst):
                    lst.append(authz_info)

    oauth_apps_with_authz: List[Dict[str, Any]] = []
    oauth_apps_without_authz: List[Dict[str, Any]] = []

    for app in apps_index:
        if str(app.get("signOnMode") or "").upper() != "OPENID_CONNECT":
            continue

        cids: List[str] = list(app.get("clientIds", []) or [])
        # Fallback: derive client_id from saved app JSON if missing
        if not cids:
            rel_file = cast(str, app.get("file") or "")
            derived_cid = try_read_client_id_from_saved_app(rel_file) if rel_file else None
            if isinstance(derived_cid, str) and derived_cid:
                cids = [derived_cid]

        matched_authz: List[AuthzInfo] = []
        for cid in cids:
            if not isinstance(cid, str) or not cid:
                continue
            for az in client_to_authz.get(cid, []):
                if all(x.get("id") != az.get("id") for x in matched_authz):
                    matched_authz.append(az)

        record: Dict[str, Any] = {
            "app": {
                "id": app.get("id"),
                "label": app.get("label"),
                "name": app.get("name"),
                "category": app.get("category"),
                "file": app.get("file"),
                "clientIds": cids,
            }
        }
        if matched_authz:
            record["authorizationServers"] = matched_authz
            oauth_apps_with_authz.append(record)
        else:
            oauth_apps_without_authz.append(record)

    oauth_apps_with_authz.sort(key=lambda x: (str(x["app"].get("label") or ""), str(x["app"].get("id") or "")))
    oauth_apps_without_authz.sort(key=lambda x: (str(x["app"].get("label") or ""), str(x["app"].get("id") or "")))
    return oauth_apps_with_authz, oauth_apps_without_authz

# ===== Main =====
def main() -> None:
    okta_domain = getenv_or_exit(OKTA_DOMAIN_ENV)
    token = getenv_or_exit(OKTA_TOKEN_ENV)

    paths = build_paths(ROOT_REPO_PATH)
    headers: Dict[str, str] = {
        "Authorization": f"SSWS {token}",
        "Accept": "application/json",
        "Content-Type": "application/json",
    }
    base_url = f"https://{okta_domain}"

    # Fresh rewrite
    reset_root_repo(ROOT_REPO_PATH)
    ensure_dir(paths["apps_saml"])
    ensure_dir(paths["apps_web"])
    ensure_dir(paths["apps_service"])
    ensure_dir(paths["authz"])

    # Collect
    apps_index = backup_apps_to_repo(base_url, headers, paths)
    authz_entries = backup_authz_to_repo(base_url, headers, paths)

    # Map
    clientid_to_app = build_clientid_to_app_index(apps_index)
    appid_to_app = build_appid_to_app_index(apps_index)
    build_authz_app_associations(authz_entries, clientid_to_app, appid_to_app)
    oauth_with, oauth_without = reverse_map_apps_to_authz(apps_index, authz_entries)

    # Final index
    index: Dict[str, Any] = {
        "root_repo": ROOT_REPO_PATH,
        "source_org": okta_domain,
        "generated_at": int(time.time()),
        "apps_count": len(apps_index),
        "authz_count": len(authz_entries),
        "apps": apps_index,
        "authz_servers": authz_entries,
        "oauth_apps_with_authz": oauth_with,
        "oauth_apps_without_authz": oauth_without,
    }
    write_json(paths["index"], index)
    print(f"Done. Index: {paths['index']}")

if __name__ == "__main__":
    main()